## به سوی ستارگان و فراتر از آن
ترجمه پست [**@yuhan6665**](https://github.com/yuhan6665) در [Xray-core discussions #1295](https://github.com/XTLS/Xray-core/discussions/1295) ترجمه شده به وسیله ChatGPT<br />
جرقه این نوشته با دیدن این ترجمه چینی به انگلیسی [seakfind](https://github.com/seakfind/examples/blob/main/xtls-vision/README.md) زده شد.<br />
وقتی ترجمه گوگل از چینی به انگلیسی در ۲۰۲۲(تاریخ پست اصلی) و ترجمه چت جی‌پی‌تی از چینی به فارسی در ۲۰۲۴ را میبینیم، پیشرفت چشم‌گیر هوش مصنوعی نمایان می‌شه.
## بخش اول: مقدمه و توضیحات XTLS
توضیح XTLS به زبان ساده: XTLS به عنوان یک فناوری، از TLS واقعی برای مخفی کردن ترافیک پروکسی در میان رایج‌ترین ترافیک اینترنتی استفاده می‌کند.<br />
در پروتکل‌های پروکسی TLS معمولی (مانند نسخه اولیه Trojan)، کلاینت پروکسی کاربر و سرور پروکسی یک اتصال واقعی TLS برقرار می‌کنند. از طریق این تونل رمزگذاری‌شده، برنامه (مانند مرورگر) با سرور هدف (مانند گوگل) یک اتصال TLS برقرار می‌کند.<br /> در این حالت، مرورگر و سرور گوگل به صورت رمزگذاری شده و انتها به انتها (e2e) ارتباط دارند و هیچ‌کس (حتی سرویس پروکسی) نمی‌تواند این ارتباط را رمزگشایی یا دستکاری کند. این همان مفهوم رمزگذاری انتها به انتها است.

```
مرورگر ---- کلاینت پروکسی ==== سرور پروکسی ---- گوگل
```
در این فرایند، داده‌های پروکسی دو بار رمزگذاری می‌شوند، اما RPRX متوجه شده است که در 99% مواقع این رمزگذاری اضافی ضرورتی ندارد. چرا؟<br />
زیرا داده‌های رمزگذاری‌شده توسط TLS 1.3 به لحاظ ظاهری کاملاً یکسان هستند و فیلترکنندگان (سانسورکنندگان) نمی‌توانند تفاوتی قائل شوند. به عبارت دیگر، منطق پروکسی تنها نیازمند:<br />

1. ایجاد یک اتصال واقعی TLS<br />
2. درون تونل رمزگذاری‌شده، ردیابی ارتباط بین مرورگر و سرور هدف (مانند گوگل) و تشخیص اینکه آیا ارتباط فعلی TLS 1.3 است.<br />
اگر اینگونه نباشد، از روش معمول TLS برای ادامه استفاده می‌شود.<br />
اگر اینگونه باشد، پس از آغاز انتقال داده‌های رمزگذاری‌شده، کلاینت پروکسی در اولین بسته رمزگذاری‌شده داخلی یک UUID (شناسه‌ی منحصر به فرد) وارد می‌کند تا به سرور پروکسی اطلاع دهد که آماده هستیم بدون رمزگذاری اضافی عمل کنیم.<br />
3. از بسته‌های رمزگذاری‌شده دوم به بعد، XTLS دیگر هیچ تغییری در داده‌ها ایجاد نمی‌کند و فقط آنها را کپی می‌کند.<br />
**این روند XTLS-RPRX-Vision نامیده می‌شود.**<br />

ویژگی‌های کلیدی این روش:

اتصال TLS بیرونی واقعی است، بنابراین فیلترکنندگان نمی‌توانند آن را رمزگشایی کنند.<br />
ترافیک بدون رمزگذاری اضافی، در پروکسی فقط کپی می‌شود. اگر فیلترکننده‌ها تغییری ایجاد کنند، پاسخ‌های عادی (مانند alert مرورگر یا سرور گوگل) دریافت می‌شود که مشابه ارتباط عادی خواهد بود.<br />
سیگنال "بدون رمزگذاری اضافی" یک UUID است که اطلاعاتی خصوصی برای پروکسی است تا از سوءاستفاده جلوگیری کند.<br />


## بخش دوم: بررسی ویژگی‌های XTLS و چالش‌های موجود

**نزدیک به یک راهکار کامل:**
از 3 اکتبر (2022)، سانسورکنندگان به شناسایی و مسدود کردن گسترده پروکسی‌های TLS روی آورده‌اند. با توجه به بحث‌ها و اطلاعات منتشرشده، مشخص شد که آنها از منابع عظیم و روش‌های یادگیری ماشینی استفاده کرده‌اند.<br />
همان‌طور که klzgrad بیان کرده است، یکی از ضعف‌های پروکسی‌های TLS معمولی مسئله‌ی رمزگذاری چندلایه (Encryption Nesting) است.<br />

همان‌طور که قبلاً توضیح داده شد، اگرچه بسته‌های رمزگذاری‌شده از دید سانسورکنندگان تفاوتی ندارند، اما رمزگذاری چندلایه یک نکته اجتناب‌ناپذیر دارد:<br />
در هر بسته، یک هدر اضافی اضافه می‌شود و هرچه لایه‌های رمزگذاری بیشتر باشد، هدر سنگین‌تر می‌شود.<br />
این افزایش ممکن است کوچک باشد، اما برای بسته‌های کوچک (مانند پاسخ‌ها) می‌تواند قابل‌توجه باشد و حتی باعث شود طول برخی بسته‌ها از محدودیت MTU شبکه فراتر رود.<br />

مهم‌تر از همه، چون هر بسته با طول یکسان هدر اضافه می‌کند، این ویژگی ممکن است دارای الگوهای قابل‌شناسایی آماری باشد.<br />

هدف از توسعه XTLS:
سازنده، RPRX فناوری XTLS را به‌طور خاص برای کاهش رمزگذاری اضافی ابداع کرد. اکنون، با معرفی جریان جدید کنترل Vision، قدرت XTLS در مقابله با سانسورکنندگان بیشتر نمایان شده است.<br />
هنگامی که داده‌های TLS 1.3 منتقل می‌شوند، XTLS در 99% مواقع بسته‌هایی با ویژگی‌های ترافیکی تقریباً بی‌نقص ارائه می‌دهد. زیرا این بسته‌ها داده‌های خام هستند و هیچ پردازشی توسط پروکسی روی آنها انجام نشده است.<br />

 **و چالش ما، TLS در TLS:**<br />
چرا گفته می‌شود که 99% بسته‌ها داده‌های خام(از نظر پروکسی، اشتباه برداشت نشود که یعنی رمزنگاری ندارند) هستند؟ پس آن 1% باقی‌مانده چیست؟<br />
برای پاسخ به این سؤال، باید به عملکرد پروکسی هنگام مواجهه با ترافیک داخلی TLS 1.3 نگاهی بیندازیم. در آغاز، چند بسته ابتدایی چه می‌کنند؟<br />

به‌صورت ساده، وقتی تونل رمزگذاری‌شده برقرار شد:<br />

بسته اول: کلاینت پروکسی -> سرور پروکسی<br />
پیام: "سلام، هدف این پروکسی Google است و این UUID من است."<br />
بسته دوم: کلاینت پروکسی <- سرور پروکسی<br />
پیام: "سلام، درخواست شما دریافت شد. می‌توانید داده‌ها را ارسال کنید."<br />
بسته سوم: مرورگر -> کلاینت پروکسی -> سرور پروکسی -> Google<br />
پیام: "سلام Google، می‌خواهم با شما ارتباط رمزگذاری‌شده برقرار کنم. این روش‌های رمزگذاری من است."<br />
(این بسته به "TLS Client Hello" معروف است.)<br />
بسته چهارم: مرورگر <- کلاینت پروکسی <- سرور پروکسی <- Google<br />
پیام: "سلام کاربر، من Google هستم. گواهی من اینجاست. از الگوریتم TLS_AES_128_GCM_SHA256 استفاده خواهیم کرد."<br />
(این بسته به "TLS Server Hello" معروف است.)<br />
بسته پنجم: مرورگر -> کلاینت پروکسی -> سرور پروکسی -> Google<br />
پیام: "دریافت شد، بیایید رمزگذاری را آغاز کنیم!"<br />
این فرایند نشان می‌دهد که هر پروتکل پروکسی TLS باید این 5 بسته را ارسال کند.<br />
اگرچه بسته‌های TLS بیرونی رمزگذاری‌شده کاملاً امن هستند، سانسورکنندگان می‌توانند از اطلاعات جانبی (مانند طول و ویژگی‌های این 5 بسته) برای شناسایی استفاده کنند.<br />
این همان نقطه‌ی کلیدی در شناسایی TLS در TLS است.<br />


**بخش سوم: تحلیل ویژگی‌های پنج بسته اولیه و استراتژی‌های مقابله**  

**پنج بسته کلیدی و ویژگی‌های آنها:**  
یکی از واضح‌ترین ویژگی‌های این پنج بسته، **طول آنها** است. جزئیات طول بسته‌ها:  

1. **بسته اول:**  
- **بسیار کوتاه**  
- تنها متغیر آن آدرس هدف است.  

2. **بسته دوم:**  
- **بسیار کوتاه**  
- تقریباً ثابت است.  

3. **بسته سوم:**  
- **کوتاه**  
- تغییرات آن اندک است؛ تنها متغیر عمده، SNI (نام سرور) هدف است.  

4. **بسته چهارم:**  
- **طولانی**  
- تغییرات زیادی دارد.  

5. **بسته پنجم:**  
- **بسیار کوتاه**  
- تغییرات اندک دارد.  

به‌صورت شهودی می‌توان فهمید که ویژگی‌های طول بسته‌ها بسیار مشخص هستند.  

**راهکار در Vision:**  
در Vision، راهکار بسیار ساده است: طول هر بسته کوتاه را به محدوده‌ای بین **900 تا 1400 بایت** افزایش می‌دهیم.  

- **تفاوت با پر کردن تصادفی سنتی:**  
  این روش با پر کردن تصادفی سنتی تفاوت دارد. در روش سنتی، تمام بسته‌ها به‌طور تصادفی پر می‌شوند. اما در اینجا، پر کردن بر اساس تحلیل دقیق جریان داخلی و فقط روی بسته‌های کلیدی انجام می‌شود.  

---

**ویژگی زمانی بسته‌ها:**  
یکی دیگر از ویژگی‌های قابل توجه، **زمان‌بندی بین ارسال بسته‌ها** است. به دلیل طراحی TLS، ترتیب ارسال این پنج بسته ثابت است:  
- مرورگر **TLS Client Hello** را ارسال می‌کند.  
- سرور Google باید **TLS Server Hello** را ارسال کند.  
- سپس مرورگر پیام **"دریافت شد، ارتباط رمزگذاری آغاز شود!"** را ارسال می‌کند.  

به این ترتیب، الگوی زمانی **CSCSC** (Client-Server-Client-Server-Client) مشخصی وجود دارد.  

**آیا سانسورکنندگان می‌توانند از این الگوی زمانی برای شناسایی TLS در TLS استفاده کنند؟**  
در حال حاضر، نمی‌توان با قاطعیت گفت که این روش شناسایی قابل‌اعتماد است. Vision هیچ‌گونه پردازشی برای مقابله با این ویژگی انجام نداده است.  

---

**راهکارهای احتمالی:**  
برخی توسعه‌دهندگان پیشنهاد کرده‌اند که از **چندگانه‌سازی (MUX)** برای مقابله با شناسایی استفاده شود.  
- **چگونه؟**  
  اگر دو ارتباط TLS مختلف در یک تونل به‌صورت چندگانه ترکیب شوند، می‌توان الگوهای زمانی متنوعی مانند **CCSSCC** (دو بسته کلاینت، دو بسته سرور و ...) ایجاد کرد.  

---

**نتیجه‌گیری این بخش:**  
جنگ فناوری مقابله با سانسور از **Shadowsocks (رمزگذاری ساده)** به **شناسایی فعال (Active Probing)** و سپس به **TLS** و اکنون به **یادگیری ماشینی** پیشرفت کرده است.  
**سرنوشت بقا یا نابودی، به چگونگی مدیریت این پنج بسته کلیدی وابسته است.**

---  
**بخش چهارم: سوالات متداول**  

**سوال: آیا طول پرشدگی بسته‌ها در Vision ثابت است؟ آیا این خودش می‌تواند به یک ویژگی آماری تبدیل شود؟**  
**پاسخ:**  
- از نظر مفاهیم امنیت شبکه، هیچ روشی کاملاً امن نیست. هر الگوریتم رمزگذاری با تلاش و منابع کافی قابل شکستن است. وظیفه ما به‌عنوان طراحان پروتکل، افزایش سختی شناسایی و شکستن آن تا حدی است که سانسورکنندگان نتوانند از پس آن برآیند.  
- طول بسته‌های TLS 1.2 و TLS 1.3 در هنگام handshake بسیار پایدار است. برای سایت‌های اصلی مانند Google، این طول‌ها به‌عنوان مقادیر ثابتی در نظر گرفته می‌شوند.  
- مقایسه Vision با handshake معمولی بدون پرشدگی نشان می‌دهد که شناسایی آن به‌شدت سخت‌تر می‌شود.  
- بحث‌های لو رفته نشان می‌دهند که یادگیری ماشینی می‌تواند پرشدگی تصادفی کمتر از **40 درصد** را تشخیص دهد. این موضوع ثابت می‌کند که یادگیری ماشینی نیز محدودیت‌هایی دارد.  

---

**سوال: چرا این پروتکل جدید Vision نامیده شده است؟**  
**پاسخ:**  
- ویژن Vision نشان‌دهنده ایده اصلی طراحی XTLS است. نسخه اولیه XTLS یک رویکرد آزمایشی و در برخی موارد پیچیده بود. Vision تلاش می‌کند تا شکل ایده‌آل و نهایی این پروتکل را ارائه دهد.  
- طبق گفته RPRX (توسعه‌دهنده XTLS):  
- **"مدیریت جریان (Flow)** باید مشکلات کلان مانند زمان‌بندی جریان را حل کند، نه ویژگی‌های خرد که توسط رمزگذاری پوشش داده می‌شوند."  
- **ویژگی‌های کلان جریان:**  
- مثل ویژگی‌هایی که در handshake پروتکل Socks5 over TLS وجود دارد.  
- هر ویژگی خاصی در handshake می‌تواند یک پروتکل جداگانه به نظر برسد، که در اینجا مدیریت جریان هوشمندانه (Schedulers) می‌تواند رفتار متفاوتی برای هر handshake ارائه دهد.  

---

**سوال: آیا Vision برای همه کاربران توصیه می‌شود؟**  
**پاسخ:**  
- خیر، همان‌طور که سایر توسعه‌دهندگان تأکید کرده‌اند، تمرکز تمام ابزارها روی یک روش خاص خطرناک است.  
- توصیه می‌شود از ویژگی‌های خاص هر ابزار استفاده کرده و ترافیک خود را پراکنده کنید.  

---

**سوال: آیا پیشنهاد می‌کنید از استانداردهای رمزنگاری ملی چین (مانند SM4) استفاده کنیم؟**  
**پاسخ:**  
- استفاده از پروتکل‌های خاص و ناشناخته مانند SM4 توصیه نمی‌شود.  
- امن‌ترین روش، مخفی شدن در میان ترافیک رایج اینترنت مانند **HTTPS** است.  
- ابزارهایی مانند **NaiveProxy** و استفاده از مرورگر Chrome برای ایجاد رفتار مشابه یک درخواست HTTPS معمولی ایده‌آل هستند.  

---

**بخش ششم: دیدگاه ما**  

از سال 2017، پروکسی‌های مبتنی بر TLS به‌طور گسترده مورد استفاده قرار گرفته‌اند. از زمان شروع انسداد گسترده خدمات Shadowsocks در سال 2019، می‌توان تصور کرد که سانسورکنندگان با صرف منابع انسانی، مالی و محاسباتی فراوان، پس از حداقل 3 سال تلاش توانسته‌اند به فناوری امروزی خود دست یابند.  

با این وجود، حتی در شرایط کنونی هم همچنان موارد زیر به چشم می‌خورد:  
- **خطا در انسداد:** سانسورکنندگان همچنان اشتباه می‌کنند.  
- **میبینیم که CDNها و IPv6 فعال هستند:** بسیاری از CDNها همچنان بدون مشکل کار می‌کنند و ارتباطات IPv6 نیز به‌خوبی ادامه دارد.  
- **افزایش دسترسی به ابزارها:** با وجود تلاش‌های سانسور، پروژه‌های Xray و گروه‌های تلگرامی همچنان رشد و افزایش کاربران را تجربه می‌کنند.  
این موارد نشان‌دهنده تأثیر محدود سانسورکنندگان در متوقف کردن اطلاعات است.

---

به‌عنوان عضوی از جامعه توسعه‌دهندگان، باید گفت که تلاش‌های ما (شامل Shadowsocks، *ray، Trojan، Naive، Hysteria، Tuic، Sing و دیگر ابزارها) طی این سال‌ها، سانسورکنندگان را به‌طور مستمر و خلاقانه تحت فشار قرار داده است.  

**جنگ پروکسی‌های TLS تازه آغاز شده است.**  
سانسورکنندگان با به‌کارگیری ابزارهای مبتنی بر هوش مصنوعی، از ناکارآمدی روش‌های قدیمی خود در شناسایی پروکسی‌های TLS پرده برداشته‌اند. از این رو، ما باید در طراحی و بهبود جزئیات ابزارها عملکرد بهتری داشته باشیم.  

**راه‌حل‌های ما چیست؟**  
- **ایجاد تنوع در ویژگی‌های ترافیک:** پراکنده‌سازی ویژگی‌ها در ابزارهای مختلف، همچون پرکردن بسته‌های handshake خاص در Vision.  
- **بهره‌گیری از مزایای ساختاری پروکسی‌ها:** ابزارهایی مانند Vision با استفاده از اطلاعات داخلی ترافیک و پرکردن هوشمند بسته‌های کلیدی، به مقابله با شناسایی‌های آماری کمک می‌کنند.  
- **استفاده از رویکردهای مشابه دیگر ابزارها:** روش‌هایی مانند NaiveProxy که با پر کردن بسته‌های خاص ترافیک مشابه HTTPS تولید می‌کند، نیز می‌توانند الهام‌بخش باشند.  

---

**نتیجه‌گیری**  
از اینکه این متن طولانی را خواندید سپاسگزاریم. از تمامی علاقه‌مندان به فناوری دعوت می‌کنیم تا ایده‌ها و نظرات خود را به اشتراک بگذارند. هر ایده و نظری می‌تواند به بخشی از نیروی ما در این نبرد تبدیل شود.  

**و در آخر، پیامی به RPRX:**  
- **"کوه‌های سبز جاودان خواهند بود و آب‌های روان پایدار. امیدواریم در بازگشت نیز همچنان جوان بمانی."**  
